@namespace EasyCsv.Components

<style>
    .mud-input-control-input-container:has(.mud-input-outlined) {
        margin-top: 0px !important;
    }
    .extra-dense {
        padding: 2px 10px !important;
    }
    .text-field-margin-fix .mud-input-slot {
        padding-top: 16px !important;
    }
    .csv-processing-table .mud-table-container {
        max-height: 60vh;
    }
    .csv-processing-popover {
        width: 500px;
    }

    .csv-processing-table .mud-toolbar {
        --mud-internal-toolbar-height: 120px !important;
    }

    .csv-processing-toolbar {
        display: flex;
        flex-direction: row;
        gap: 16px;
    }

    .csv-processing-toolbar-search-field {
        width: 350px;
    }

    .csv-processing-popover .mud-nested-list > .mud-list-item {
        padding-right: 25px;
    }
    .easy-csv-fullscreen-backdrop {
        position: fixed;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        z-index: 1000; /* This should be lower than the popover's z-index but higher than most other elements on your page */
        background-color: rgba(0, 0, 0, 0); /* You can adjust the opacity as needed */
    }
</style>

@if (EasyCsv?.CsvContent != null && EasyCsv.ColumnNames() != null && ProcessingOptions != null) 
{
    int tagsColumnIndex = EasyCsv.ColumnNames()?.IndexOf(InternalColumnNames.Tags) ?? -1;
    int referenceColumnIndex = EasyCsv.ColumnNames()?.IndexOf(InternalColumnNames.References) ?? -1;
    string[] columnNames = EasyCsv.ColumnNames()!;
    @foreach (var test in _referencesBackDropsOpen)
    {
        <MudPopover @onclick="() => { _referencesBackDropsOpen[test.Key] = false; _referencesOpen[test.Key] = false; }" Class="easy-csv-fullscreen-backdrop" Open="_referencesOpen[test.Key]">
            <ChildContent>
                @{
                    @if (_referencesBackDropsOpen[test.Key] != true)
                    {
                        _referencesBackDropsOpen[test.Key] = true;
                        StateHasChanged();
                    }
                }
            </ChildContent>
        </MudPopover>
    }

    <MudTable T="CsvRow" Class="csv-processing-table" FixedHeader="true" RowsPerPage="10" Items="GetFilteredRows()"
              Striped Bordered Dense Hover Elevation="2" ToolBarContent="@ToolBarContent()" >
        <HeaderContent>
            @if (Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning)
            {
                @if (tagsColumnIndex >= 0)
                {
                    <MudTh>Tags</MudTh>
                }

                @if (referenceColumnIndex >= 0)
                {
                    <MudTh>References</MudTh>
                }
            }
            @for (var i = 0; i < columnNames.Length; i++)
            {
                int mid = columnNames.Length / 2;
                var anchorOrigin = i >= mid ? Origin.BottomLeft : Origin.BottomRight;
                var transformOrigin = i >= mid ? Origin.TopRight : Origin.TopLeft;
                var column = columnNames[i];
                if (i == tagsColumnIndex || i == referenceColumnIndex) continue;
                _popOverDict.TryAdd(column, false);
                if (!_strategyBuckets.ContainsKey(column))
                {
                    _strategyBuckets.Add(column, new StrategyBucket(column, InvokeStateHasChanged));
                }

                _strategyBuckets[column].SetOrigins(anchorOrigin, transformOrigin);
                <MudTh>
                    <div style="display: flex; flex-direction: row; justify-content: space-between">
                        @column
                        <MudIconButton Disabled="Busy" Icon="@Icons.Material.Filled.OpenInFull" OnClick="_ => TogglePopover(column)"></MudIconButton>
                    </div>
                    <MudPopover Open="_popOverDict[column]" Style="@($"max-height:{Stepper.MaxStrategySelectHeight}")" Class="csv-processing-popover" OverflowBehavior="OverflowBehavior.FlipAlways" AnchorOrigin="anchorOrigin" TransformOrigin="transformOrigin">
                        <CascadingValue TValue="CsvProcessingStepper" Value="Stepper" IsFixed="true">
                            <CascadingValue TValue="StrategyBucket" Value="_strategyBuckets[column]" IsFixed="true">
                                <MudList Clickable="true" Style="z-index: inherit">
                                    <MudListSubheader>
                                        <div style="display: flex; flex-direction: row; justify-content: space-between">
                                            <MudText Class="mt-4" Typo="Typo.h5">
                                                Column Strategies&nbsp;
                                                @if (Stepper.ShowColumnNameInStrategySelect)
                                                {
                                                    @:(@column)
                                                }
                                            </MudText>
                                            <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="x => TogglePopover(column, false)"></MudIconButton>
                                        </div>
                                    </MudListSubheader>
                                    @if (Stepper.SearchBar)
                                    {
                                        <MudListItem>
                                            <MudTextField T="string" Disabled="_strategyBuckets[column].IsAnySelected()" Immediate="true" Placeholder="Search strategies" Variant="Variant.Outlined" Value="_strategyBuckets[column].SearchQuery"
                                                          ValueChanged="_strategyBuckets[column].SetSearchQuery"
                                                          Clearable="true" OnClearButtonClick="() => _strategyBuckets[column].SetSearchQuery(string.Empty)"></MudTextField>
                                        </MudListItem>
                                    }
                                    @ProcessingOptions(column)
                                    @if (_strategyBuckets[column].IsAnySelected() || Stepper.RunOperationNoneSelectedBehaviour == RunOperationNoneSelectedBehaviour.Disabled)
                                    {
                                        <MudListItem>
                                            <div style="display: flex; flex-direction: row; align-items: center; justify-content: space-between;">
                                                <div></div>
                                                <MudButton Disabled="!_strategyBuckets[column].StrategySelectedAndRunAllowed()" Variant="Variant.Filled" Color="Color.Info" OnClick="x => _strategyBuckets[column].StrategyPicked()">Run Operation</MudButton>
                                            </div>
                                        </MudListItem>
                                    }
                                </MudList>
                                @if (_popOverDict[column] && Stepper.CloseBehaviour is CloseBehaviour.ClickAway or CloseBehaviour.CloseButtonAndClickAway)
                                {
                                    <div @onclick="() => TogglePopover(column, false)" class="easy-csv-fullscreen-backdrop"></div>
                                }
                            </CascadingValue>
                        </CascadingValue>
                    </MudPopover>
                </MudTh>
            }
            @if (Stepper.TagsAndReferencesLocation == ColumnLocation.End)
            {
                @if (referenceColumnIndex >= 0)
                {
                    <MudTh>References</MudTh>
                }

                @if (tagsColumnIndex >= 0)
                {
                    <MudTh>Tags</MudTh>
                }
            }
        </HeaderContent>
        <RowTemplate Context="row">
            @if (Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning)
            {
                @TagDataCell(tagsColumnIndex, row)
                @ReferencesDataCell(referenceColumnIndex, row)
            }
            @for (int i = 0; i < row.Count; i++)
            {
                var value = row.ValueAt(i);
                if (i != tagsColumnIndex && i != referenceColumnIndex)
                {
                    <MudTd Class="extra-dense">@value</MudTd>
                }
            }
            @if (Stepper.TagsAndReferencesLocation == ColumnLocation.End)
            {
                @ReferencesDataCell(referenceColumnIndex, row)
                @TagDataCell(tagsColumnIndex, row)
            }
        </RowTemplate>
        <PagerContent>
            <MudTablePager></MudTablePager>
        </PagerContent>
    </MudTable>
}

@code {
    internal static Color[] DefaultColors = [Color.Primary, Color.Secondary, Color.Success, Color.Error, Color.Tertiary, Color.Dark, Color.Warning];

    [Parameter] public Func<IGrouping<int, (int ReferenceCsvId, int ReferenceRowId)>, string>? FormatReferenceText { get; set; } 
    [Parameter] public RenderFragment<string>? ProcessingOptions { get; set; }
    [Parameter] public CsvProcessingStepper Stepper { get; set; } = null!;
    [Parameter] public bool Busy { get; set; } 
    [Parameter] public IEasyCsv? EasyCsv
    {
        get => _easyCsv;
        set
        {
            _easyCsv = value;
            OnEasyCsvChanged();
        }
    }

    private readonly record struct ReferenceGroup(CsvRow Row, int ReferenceGroupIndex);

    private Dictionary<ReferenceGroup, bool> _referencesOpen = new();
    private Dictionary<ReferenceGroup, bool> _referencesBackDropsOpen = new();
    private Dictionary<string, bool> _popOverDict = new ();
    private string[] _searchColumns = [];
    private string[] _searchTags = [];
    private Dictionary<string, StrategyBucket> _strategyBuckets = new();
    private Dictionary<string, Color> _tagColors = new();
    private IEasyCsv? _easyCsv;
    private string? _sq;

    public IEnumerable<CsvRow> GetFilteredRows()
    {
        if (IsFiltered())
        {
            var tagsColumnIndex = EasyCsv?.ColumnNames()?.IndexOf(x => x == InternalColumnNames.Tags) ?? -1;
            return EasyCsv?.CsvContent.Where(x => x.AnyColumnContainsValues(_searchColumns, _sq) && (tagsColumnIndex < 0 || x.MatchesIncludeTagsAndExcludeTags(tagsColumnIndex, _searchTags, null))) ?? Enumerable.Empty<CsvRow>();
        }
        return EasyCsv?.CsvContent ?? Enumerable.Empty<CsvRow>();
    }

    [Pure]
    internal HashSet<int> FilteredRowIndexes()
    {
        var tagsColumnIndex = EasyCsv?.ColumnNames()?.IndexOf(x => x == InternalColumnNames.Tags) ?? -1;
        return EasyCsv?.CsvContent
            .Select((row, index) => (row, index))
            .Where(x => x.row.AnyColumnContainsValues(_searchColumns, _sq))
            .Where(x => tagsColumnIndex < 0 || x.row.MatchesIncludeTagsAndExcludeTags(tagsColumnIndex, _searchTags, null))
            .Select(x => x.index)
            .ToHashSet() ?? new HashSet<int>();
    }

    public bool IsFiltered()
    {
        if ((_searchColumns.Length > 0 && !string.IsNullOrWhiteSpace(_sq)) || _searchTags.Length > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    private void AddTag(string tag)
    {
        if (!_tagColors.ContainsKey(tag))
        {
            int colorIndex = _tagColors.Count % DefaultColors.Length;
            Color color = DefaultColors[colorIndex];
            _tagColors.Add(tag, color);
        }
    }

    private void OnEasyCsvChanged()
    {
        _popOverDict.Clear();
        _strategyBuckets.Clear();
        _referencesBackDropsOpen.Clear();
        _referencesOpen.Clear();
        var columnNames = EasyCsv?.ColumnNames();
        if (columnNames != null)
        {
            _searchColumns = _searchColumns.Where(x => columnNames.Contains(x)).ToArray();
        }
        else
        {
            _searchColumns = [];
        }
    }

    public Task SetSearchQuery(string? searchQuery)
    {
        if ((string.IsNullOrWhiteSpace(searchQuery) && string.IsNullOrWhiteSpace(_sq)) || _sq?.Equals(searchQuery) == true) return Task.CompletedTask;
        _sq = searchQuery;
        return InvokeStateHasChanged();
    }

    internal void TogglePopover(string column)
    {
        bool value = _popOverDict[column];
        if (value)
        {
            _popOverDict[column] = false;
        }
        else if (!_popOverDict.Values.Any(x => x)) _popOverDict[column] = true;
    }
    internal void TogglePopover(string column, bool open)
    {
        if (!open) _popOverDict[column] = open;
        else if (!_popOverDict.Values.Any(x => x)) _popOverDict[column] = true;
    }

    private void RemoveTag(CsvRow row, int tagsColumnIndex, string tag)
    {
        row.RemoveTag(tagsColumnIndex, tag);
    }

    private void RemoveReference(CsvRow row, int referencesColumnIndex, int referenceCsvId, int referenceRowId)
    {
        row.RemoveReference(referencesColumnIndex, referenceCsvId, referenceRowId);
    }

    private void RemoveReference(CsvRow row, string tag, int tagsIndex)
    {
        var tags = row.ValueAt(tagsIndex)?.ToString()?.Split(",", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        int? tagIndex = tags?.IndexOf(tag);
        if (tagIndex >= 0)
        {
            string newTagsStr = string.Join(",", tags!.Take(tagsIndex).Skip(1));
            row.SetValueAtIndex(tagsIndex, newTagsStr); 
        }
    }

    private string DefaultFormatReferenceText(IGrouping<int, (int CsvIndex, int RowIndex)> grouping)
    {
        var count = grouping.Count();
        string rows = count == 1 ? "Row" : "Rows";
        return $"Ref Csv: {grouping.Key + 1}, {rows}: {string.Join(" | ", grouping.Select(x => x.RowIndex + 1))}";
    }

    internal Task InvokeStateHasChanged()
    {
        return InvokeAsync(StateHasChanged);
    }

    private RenderFragment? TagDataCell(int tagsColumnIndex, CsvRow row)
    {
        if (tagsColumnIndex >= 0)
        {
            var tags = row.ValueAt(tagsColumnIndex)?.ToString()?.Split(",", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
            return @<MudTd Class="extra-dense">
                       @if (tags?.Any() == true)
                       {
                           <MudChipSet AllClosable="true">
                               @foreach (var tag in tags)
                               {
                                   AddTag(tag);
                                   <MudChip Text="@tag" Color="_tagColors[tag]" Size="Size.Small" OnClose="x => RemoveTag(row, tagsColumnIndex, tag)"/>
                               }
                           </MudChipSet>
                       }
                   </MudTd>;
        }
        return null;
    }

    private RenderFragment? ToolBarContent()
    {
        if (!Stepper.UseToolbar) return null;
        var columnNames = EasyCsv?.ColumnNames();
        if (columnNames == null) return null;
        return @<div class="csv-processing-toolbar">
                   <MudTextField Disabled="Busy" T="string" Class="csv-processing-toolbar-search-field" DebounceInterval="Stepper.SearchDebounceInterval" Immediate="true" Label="Search Csv"
                                 HelperText="Value to search for" HelperTextOnFocus Variant="Variant.Outlined" Value="_sq" ValueChanged="x => SetSearchQuery(x)" 
                                 Clearable OnClearButtonClick="x => SetSearchQuery(null)"/>
                   <CascadingValue TValue="CsvProcessingStepper" Value="@Stepper" IsFixed="true"  >
                       <MultiColumnSelect Disabled="Busy" InitializeWithStrategyBucketColumnName="false" Label="Columns To Search" @bind-ColumnNames="_searchColumns" SelectAll="true" SelectAllText="Search All Columns" ></MultiColumnSelect>
                       <MultiTagSelect Disabled="Busy" Label="Tag Filter" @bind-Tags="_searchTags" HideNoTags="true" ></MultiTagSelect>
                   </CascadingValue>
               </div>;
    }

    private RenderFragment? ReferencesDataCell(int referenceColumnIndex, CsvRow row)
    {
        if (referenceColumnIndex >= 0)
        {
            var anchorOrigin = Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning ? Origin.BottomRight : Origin.BottomLeft;
            var transformOrigin = Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning ? Origin.TopLeft : Origin.TopRight;
            var references = row.References(referenceColumnIndex);
            return @<MudTd Class="extra-dense">
                       @if (references?.Any() == true && Stepper.Runner?.ReferenceCsvs.Count > 0)
                       {
                           int i = -1;
                           <MudChipSet>
                               @foreach (IGrouping<int, (int CsvIndex, int RowIndex)> group in references.Where(x => Utils.IsValidIndex(x.CsvIndex, Stepper.Runner?.ReferenceCsvs.Count ?? -1)).GroupBy(x => x.CsvIndex))
                               {
                                   i++;
                                   int groupIndex = i;
                                   var referenceGroup = new ReferenceGroup(row, groupIndex);
                                   _referencesOpen.TryAdd(referenceGroup, false);
                                   _referencesBackDropsOpen.TryAdd(referenceGroup, false); 
                                   string text = FormatReferenceText != null
                                       ? FormatReferenceText(group)
                                       : DefaultFormatReferenceText(group);
                                   <MudChip Text="@text" Color="@Stepper.ReferenceChipColor" Size="Size.Small" OnClick="x => _referencesOpen[referenceGroup] = true"/>
                                   <MudPopover AnchorOrigin="anchorOrigin" TransformOrigin="transformOrigin" Style="color: var(--mud-palette-dark-text); background-color: var(--mud-palette-grey-darker); padding: 10px; max-width: 1000px;" Open="_referencesOpen[referenceGroup]">
                                       <ChildContent>
                                           @{
                                               string referencesStr = references.Length == 1 ? "reference" : "references";
                                               var dictionaryArray = new Dictionary<string, string?>[references.Length];
                                               int j = 0;
                                               foreach (var reference in references)
                                               {
                                                   dictionaryArray[j] = Stepper.Runner.ReferenceCsvs[reference.CsvIndex].Csv.CsvContent[reference.RowIndex].ToStringDictionary();
                                                   j++;
                                               }
                                           }
                                           @ExampleCsv(dictionaryArray, $"{references.Length} {referencesStr} in {Stepper.Runner.ReferenceCsvs[group.Key].FileName}", false)
                                       </ChildContent>
                                   </MudPopover>

                               }
                           </MudChipSet>
                       }
                   </MudTd>;
        }
        return null;
    }
}

@namespace EasyCsv.Components.Internal
@using EasyCsv.Components.Processing.Strategies.Editing

<style>
    .mud-input-control-input-container:has(.mud-input-outlined) {
        margin-top: 0px !important;
    }
    .extra-dense {
        padding: 2px 10px !important;
    }
    .text-field-margin-fix .mud-input-slot {
        padding-top: 16px !important;
    }
    .csv-processing-table .mud-table-container {
        max-height: 60vh;
    }
    .csv-processing-popover {
        width: @_popOverWidthPixels;
    }

    .csv-processing-table .mud-toolbar {
        --mud-internal-toolbar-height: 120px !important;
    }

    .mud-table-dense.csv-processing-table .mud-tr:first-child:has(.mud-th) {
        border-left: 1px;
    }

    .csv-processing-table-th-name {
    }


    .csv-processing-table-th-button {
    }


    .csv-processing-toolbar {
        display: flex;
        flex-direction: row;
        gap: 16px;
        width: 100%;
        padding: 0 13px;
        justify-content: space-between;
    }

    .csv-processing-toolbar-options {
        display: flex;
        flex-direction: row;
        gap: 16px;
        align-items: baseline;
    }

    .csv-processing-toolbar-atlas {
        
    }

    .csv-processing-toolbar-forward-back-container {
        
    }

    .csv-processing-toolbar-full-csv-operations-button {

    }
    .csv-processing-toolbar-atlas-item {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
    }

    .csv-processing-toolbar-search-field {
        width: 350px;
    }

    .mud-table-dense th.mud-table-cell.csv-processing-table-th .mud-button-root {
        
    }

    .mud-table-dense th.mud-table-cell.csv-processing-table-th {
        padding-right: 18px;
        padding-left: 7px;
    }

    .csv-processing-popover .mud-nested-list > .mud-list-item {
        padding-right: 25px;
    }
    .easy-csv-fullscreen-backdrop {
        position: fixed;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        z-index: 1000; /* This should be lower than the popover's z-index but higher than most other elements on your page */
        background-color: rgba(0, 0, 0, 0); /* You can adjust the opacity as needed */
    }

    .csv-processing-table .mud-table-cell input[type="text"] {
        padding: 15px 12px 10px;
    }
</style>

@if (Stepper?.Runner is {CurrentCsv: not null, CurrentCsvColumnNames: not null} && ColumnOptions != null) 
{
    string[] columnNames = Stepper.Runner.CurrentCsvColumnNames!;
    int tagsColumnIndex = columnNames.IndexOf(InternalColumnNames.Tags);
    int referenceColumnIndex = columnNames.IndexOf(InternalColumnNames.References);
    @foreach (var backDrop in _referencesBackDropsOpen)
    {
        <MudPopover @onclick="() => { _referencesBackDropsOpen[backDrop.Key] = false; _referencesOpen[backDrop.Key] = false; }" Class="easy-csv-fullscreen-backdrop" Open="_referencesOpen[backDrop.Key]">
            <ChildContent>
                @{
                    @if (_referencesBackDropsOpen[backDrop.Key] != true)
                    {
                        _referencesBackDropsOpen[backDrop.Key] = true;
                        StateHasChanged();
                    }
                }
            </ChildContent>
        </MudPopover>
    }

    <MudTable T="CsvRow" Class="csv-processing-table" FixedHeader="true" RowsPerPage="10" Items="GetFilteredRows()"
              Striped Bordered Dense Hover Elevation="2" ToolBarContent="@ToolBarContent()" EditTrigger="Stepper.EditTrigger" 
              EditButtonPosition="Stepper.EditButtonPosition" CanCancelEdit="Stepper.CanCancelEdit" CancelEditIcon="@Stepper.CancelEditIcon"
              CancelEditTooltip="@Stepper.CancelEditTooltip" CommitEditIcon="@Stepper.CommitEditIcon" CommitEditTooltip="@Stepper.CommitEditTooltip"
              IsEditRowSwitchingBlocked="Stepper.IsEditRowSwitchingBlocked" OnCancelEditClick="@Stepper.OnCancelEditClick" OnCommitEditClick="@Stepper.OnCommitEditClick"
              ReadOnly="@Stepper.ReadOnly" OnPreviewEditClick="OnPreviewEdit" RowEditCancel="x => OnCancelEdit(x)" RowEditCommit="x => OnConfirmEdit(x)"
              RowEditPreview="@Stepper.RowEditPreview" ApplyButtonPosition="@Stepper.ApplyButtonPosition" RowEditingTemplate="RowEditTemplate(tagsColumnIndex, referenceColumnIndex)" >
        <HeaderContent>
            @if (Stepper.EnableRowDeleting)
            {
                <MudTh></MudTh>
            }
            @if (Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning)
            {
                @if (tagsColumnIndex >= 0)
                {
                    <MudTh>Tags</MudTh>
                }

                @if (referenceColumnIndex >= 0)
                {
                    <MudTh>References</MudTh>
                }
            }
            @for (var i = 0; i < columnNames.Length; i++)
            {
                int mid = columnNames.Length / 2;
                var anchorOrigin = i >= mid ? Origin.BottomLeft : Origin.BottomRight;
                var transformOrigin = i >= mid ? Origin.TopRight : Origin.TopLeft;
                var column = columnNames[i];
                string? cursorStyle = Stepper.EnableSorting ? "cursor: pointer; user-select: none;" : null;
                if (i == tagsColumnIndex || i == referenceColumnIndex) continue;
                <MudTh Class="csv-processing-table-th">
                    <div style="display: flex; flex-direction: row; gap: 10px; align-items: center;">
                        <div @onclick="() => OnColumnNameClick(column)" @onclick:stopPropagation="Stepper.EnableSorting" style="@cursorStyle" class="csv-processing-table-th-name">
                            @column
                        </div>
                        <div class="csv-processing-table-th-button">
                            <MudTooltip Delay="750" Text="View Column Strategies">
                                <MudIconButton Disabled="Busy" Icon="@Stepper.ViewColumnOperationsIcon" OnClick="_ => TogglePopover(column)"></MudIconButton>
                            </MudTooltip>
                        </div>
                    </div>
                    @StrategyBucketPopover(column, anchorOrigin, transformOrigin, fullCsv: false)
                </MudTh>
            }
            @if (Stepper.TagsAndReferencesLocation == ColumnLocation.End)
            {
                @if (referenceColumnIndex >= 0)
                {
                    <MudTh>References</MudTh>
                }

                @if (tagsColumnIndex >= 0)
                {
                    <MudTh>Tags</MudTh>
                }
            }
        </HeaderContent>
        <RowTemplate Context="row">
            @if (Stepper.EnableRowDeleting)
            {
                <MudTd>
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" OnClick="x => DeleteRow(row)" > </MudIconButton>
                </MudTd>
            }
            @if (Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning)
            {
                @TagDataCell(tagsColumnIndex, row)
                @ReferencesDataCell(referenceColumnIndex, row)
            }
            @for (int i = 0; i < row.Count; i++)
            {
                var value = row.ValueAt(i);
                if (i != tagsColumnIndex && i != referenceColumnIndex)
                {
                    <MudTd Class="extra-dense">@value</MudTd>
                }
            }
            @if (Stepper.TagsAndReferencesLocation == ColumnLocation.End)
            {
                @ReferencesDataCell(referenceColumnIndex, row)
                @TagDataCell(tagsColumnIndex, row)
            }
        </RowTemplate>
        <PagerContent>
            <MudTablePager>
                
            </MudTablePager>
        </PagerContent>
    </MudTable>
}

@code {
    internal static Color[] DefaultColors = [Color.Primary, Color.Secondary, Color.Success, Color.Error, Color.Tertiary, Color.Dark, Color.Warning];

    [Parameter] public Func<IGrouping<int, (int ReferenceCsvId, int ReferenceRowId)>, string>? FormatReferenceText { get; set; } 
    [Parameter] public RenderFragment<string>? ColumnOptions { get; set; }
    [Parameter] public RenderFragment? FullCsvOptions { get; set; }
    [Parameter] public CsvProcessingStepper Stepper { get; set; } = null!;
    [Parameter] public bool Busy { get; set; } 
    [Parameter] public IEasyCsv? EasyCsv
    {
        get => _easyCsv;
        set
        {
            _easyCsv = value;
            OnEasyCsvChanged();
        }
    }

    private readonly record struct ReferenceGroup(CsvRow Row, int ReferenceGroupIndex);

    private CsvRow? _rowBeingEdited;
    private Dictionary<ReferenceGroup, bool> _referencesOpen = new();
    private Dictionary<ReferenceGroup, bool> _referencesBackDropsOpen = new();
    private Dictionary<string, bool> _columnPopOverDict = new ();
    private string[] SearchColumns { get; set; } = [];
    private string[] _searchTags = [];
    private Dictionary<string, ColumnValueType> _columnValueTypes = [];
    private Dictionary<string, StrategyBucket> _columnStrategyBuckets = new();
    private Dictionary<string, string[]> _cachedAllValues = new();
    private Dictionary<string, Color> _tagColors = new();
    private IEasyCsv? _easyCsv;
    private string? _sq;
    private string _popOverWidthPixels => Stepper?.EnableChangeEditColumnValueType == true ? "600px" : "500px";

    public IEnumerable<CsvRow> GetFilteredRows()
    {
        if (IsFiltered())
        {
            var tagsColumnIndex = Stepper?.Runner?.CurrentCsvColumnNames?.IndexOf(x => x == InternalColumnNames.Tags) ?? -1;
            return Stepper?.Runner?.CurrentCsv?.CsvContent.Where(x => x.AnyColumnContainsValues(SearchColumns, _sq) && (tagsColumnIndex < 0 || x.MatchesIncludeTagsAndExcludeTags(tagsColumnIndex, _searchTags, null))) ?? Enumerable.Empty<CsvRow>();
        }
        return Stepper?.Runner?.CurrentCsv?.CsvContent ?? Enumerable.Empty<CsvRow>();
    }

    [Pure]
    internal HashSet<int> FilteredRowIndexes()
    {
        var tagsColumnIndex = Stepper?.Runner?.CurrentCsvColumnNames?.IndexOf(x => x == InternalColumnNames.Tags) ?? -1;
        return Stepper?.Runner?.CurrentCsv?.CsvContent
            .Select((row, index) => (row, index))
            .Where(x => x.row.AnyColumnContainsValues(SearchColumns, _sq))
            .Where(x => tagsColumnIndex < 0 || x.row.MatchesIncludeTagsAndExcludeTags(tagsColumnIndex, _searchTags, null))
            .Select(x => x.index)
            .ToHashSet() ?? new HashSet<int>();
    }

    public bool IsFiltered()
    {
        if ((SearchColumns.Length > 0 && !string.IsNullOrWhiteSpace(_sq)) || _searchTags.Length > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    private void SetColumnValueType(string columnName, ColumnValueType columnValueType)
    {
        _columnValueTypes[columnName] = columnValueType;
    }

    private void AddTag(string tag)
    {
        if (!_tagColors.ContainsKey(tag))
        {
            int colorIndex = _tagColors.Count % DefaultColors.Length;
            Color color = DefaultColors[colorIndex];
            _tagColors.Add(tag, color);
        }
    }

    private void OnEasyCsvChanged()
    {
        _columnPopOverDict.Clear();
        _columnStrategyBuckets.Clear();
        _referencesBackDropsOpen.Clear();
        _referencesOpen.Clear();
        var columnNames = Stepper?.Runner?.CurrentCsvColumnNames;
        if (columnNames != null)
        {
            _columnValueTypes = _columnValueTypes.Where(x => columnNames.Contains(x.Key)).ToDictionary(x => x.Key, x => x.Value);
            Array.ForEach(columnNames, x => _columnValueTypes.TryAdd(x, Stepper!.DefaultColumnValueType));
            _cachedAllValues = _cachedAllValues.Where(x => columnNames.Contains(x.Key)).ToDictionary(x => x.Key, x => x.Value);
        }
        if (Stepper?.AutoSelectAllColumnsToSearch == true && columnNames != null)
        {
            SearchColumns = columnNames;
        }
        else if (columnNames != null)
        {
            SearchColumns = SearchColumns.Where(x => columnNames.Contains(x)).ToArray();
        }
        else
        {
            SearchColumns = [];
        }
    }

    public Task SetSearchQuery(string? searchQuery)
    {
        if ((string.IsNullOrWhiteSpace(searchQuery) && string.IsNullOrWhiteSpace(_sq)) || _sq?.Equals(searchQuery) == true) return Task.CompletedTask;
        _sq = searchQuery;
        return InvokeStateHasChanged();
    }

    internal void TogglePopover(string column)
    {
        bool value = _columnPopOverDict[column];
        if (value)
        {
            _columnPopOverDict[column] = false;
        }
        else if (!_columnPopOverDict.Values.Any(x => x)) _columnPopOverDict[column] = true;
    }

    private void TogglePopover(string column, bool open)
    {
        if (!open) _columnPopOverDict[column] = open;
        else if (!_columnPopOverDict.Values.Any(x => x)) _columnPopOverDict[column] = true;
    }

    private void DeleteRow(CsvRow row)
    {
        int rowIndex = Stepper.Runner!.CurrentCsv!.CsvContent.IndexOf(row);
        if (rowIndex < 0) return;
        var deleteRowEdit = new DeleteRowEdit(row);
        Stepper.Runner.AddReversibleEdit(deleteRowEdit);
    }


    private void RemoveTag(CsvRow row, int tagsColumnIndex, string tag)
    {
        int rowIndex = Stepper.Runner!.CurrentCsv!.CsvContent.IndexOf(row);
        if (rowIndex < 0) return;
        var removeTagEdit = new RemoveTagEdit(row, tag, tagsColumnIndex);
        Stepper.Runner.AddReversibleEdit(removeTagEdit);
    }

    private void RemoveReference(CsvRow row, int referencesColumnIndex, int referenceCsvId, int referenceRowId)
    {
        int rowIndex = Stepper.Runner!.CurrentCsv!.CsvContent.IndexOf(row);
        if (rowIndex < 0) return;
        var removeReferenceEdit = new RemoveReferenceEdit(row, referenceCsvId, referenceRowId, referencesColumnIndex);
        Stepper.Runner.AddReversibleEdit(removeReferenceEdit);
    }

    private string DefaultFormatReferenceText(IGrouping<int, (int CsvIndex, int RowIndex)> grouping)
    {
        var count = grouping.Count();
        string rows = count == 1 ? "Row" : "Rows";
        return $"Ref Csv: {grouping.Key + 1}, {rows}: {string.Join(" | ", grouping.Select(x => x.RowIndex + 1))}";
    }

    internal Task InvokeStateHasChanged()
    {
        return InvokeAsync(StateHasChanged);
    }

    private string? _currentSortedColumn;
    private SortDirection _currentSortDirection = SortDirection.Ascending;
    private void OnColumnNameClick(string columnName)
    {
        if (Stepper?.Runner?.CurrentCsv == null || !Stepper.EnableSorting) return;
        if (_currentSortedColumn == columnName)
        {
            _currentSortDirection = _currentSortDirection == SortDirection.Ascending 
                ? SortDirection.Descending 
                : _currentSortDirection == SortDirection.Descending 
                    ? SortDirection.None
                    : SortDirection.Ascending;
            if (_currentSortDirection == SortDirection.None)
            {
                Stepper.Runner.SortCurrentBackToOriginalOrder();
            }
            else
            {
                bool ascending = _currentSortDirection == SortDirection.Ascending;
                Stepper.Runner.CurrentCsv.Mutate(x =>
                {
                    x.SortCsv(columnName, ascending);
                }, saveChanges: false);
            }
        }
        else
        {
            _currentSortedColumn = columnName;
            _currentSortDirection = SortDirection.Ascending;
            Stepper.Runner.CurrentCsv.Mutate(x =>
            {
                x.SortCsv(columnName, ascending: true);
            }, saveChanges: false);
        }
    }

    private void ApplyCurrentColumnSort()
    {
        if (Stepper?.Runner?.CurrentCsv == null) return;
        if (_currentSortedColumn == null || _currentSortDirection == SortDirection.None)
        {
            Stepper.Runner.SortCurrentBackToOriginalOrder();
        }
        else
        {
            bool ascending = _currentSortDirection == SortDirection.Ascending;
            Stepper.Runner.CurrentCsv!.Mutate(x =>
            {
                x.SortCsv(_currentSortedColumn, ascending);
            }, saveChanges: false);
        }
    }

    private enum SortDirection
    {
        Ascending,
        Descending,
        None
    }

    private async Task OnPreviewEdit(object obj)
    {
        if (obj is not CsvRow row) return;
        _rowBeingEdited = row.Clone();
        if (Stepper?.OnPreviewEditClick != null)
        {
            await Stepper.OnPreviewEditClick.InvokeAsync();
        }
    }

    private Task OnCancelEdit(object obj)
    {
        _rowBeingEdited = null;
        return Stepper.OnCancelEditClick.InvokeAsync();
    }

    private Task OnConfirmEdit(object obj)
    {
        if (_rowBeingEdited == null || Stepper?.Runner == null || obj is not CsvRow row) return Task.CompletedTask;
        if (_rowBeingEdited.ValuesEqual(row) == false)
        {
            int rowIndex = Stepper.Runner.CurrentCsv!.CsvContent.IndexOf(row);
            if (rowIndex < 0) return Task.CompletedTask;
            var rowClone = row.Clone();
            var modifyRowEdit = new ModifyRowEdit(row, rowClone, _rowBeingEdited);
            Stepper.Runner.AddReversibleEdit(modifyRowEdit);
            StateHasChanged();
            return Stepper.OnCommitEditClick.InvokeAsync();
        }
        return Task.CompletedTask;
    }

    private RenderFragment EditCell(CsvRow row, int columnIndex)
    {
        if (_rowBeingEdited == null) return @<MudTd></MudTd>;
        var columnName = row.KeyAt(columnIndex);
        var valueType = _columnValueTypes.GetValueOrDefault(columnName, Stepper.DefaultColumnValueType);
        switch (valueType)
        {
            case ColumnValueType.Text:
                return @<ProcessingEditTextCell ColumnName="@columnName" Row="_rowBeingEdited" />;
            case ColumnValueType.DateTime:
                return @<ProcessingEditDateTimeCell ColumnName="@columnName" Row="_rowBeingEdited" />;
            case ColumnValueType.Integer:
                return @<ProcessingEditIntegerField ColumnName="@columnName" Row="_rowBeingEdited" />;
            case ColumnValueType.Decimal:
                return @<ProcessingEditDecimalField ColumnName="@columnName" Row="_rowBeingEdited" />;
            case ColumnValueType.SelectFromAll:
                if (!_cachedAllValues.TryGetValue(columnName, out var allValues))
                {
                    allValues = Stepper?.Runner?.CurrentCsv?.CsvContent?.Select(x => x[columnName]?.ToString()).Distinct().ToArray() ?? [];
                    _cachedAllValues[columnName] = allValues;
                }
                return @<ProcessingAutoSelectCell AllValues="allValues" ColumnName="@columnName" Row="@_rowBeingEdited" />;
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private RenderFragment? TagDataCell(int tagsColumnIndex, CsvRow row, bool allowDelete=true)
    {
        if (tagsColumnIndex >= 0)
        {
            var tags = row.ValueAt(tagsColumnIndex)?.ToString()?.Split(",", StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
            return @<MudTd Class="extra-dense">
                       @if (tags?.Any() == true)
                       {
                           <MudChipSet AllClosable="@allowDelete">
                               @foreach (var tag in tags)
                               {
                                   AddTag(tag);
                                   <MudChip Text="@tag" Color="_tagColors[tag]" Size="Size.Small" OnClose="x => RemoveTag(row, tagsColumnIndex, tag)"/>
                               }
                           </MudChipSet>
                       }
                   </MudTd>;
        }
        return null;
    }

    private RenderFragment ToolBarContent()
    {
        bool isPreviousEdit = Utils.IsValidIndex(Stepper.Runner?.CurrentRowEditIndex, Stepper.Runner?.CurrentReversibleEdits?.Count ?? -1);
        bool isNextEdit = Utils.IsValidIndex(Stepper.Runner?.CurrentRowEditIndex + 1, Stepper.Runner?.CurrentReversibleEdits?.Count ?? -1);
        var columnNames = Stepper?.Runner?.CurrentCsvColumnNames;
        return @<div class="csv-processing-toolbar">
                   <div class="csv-processing-toolbar-atlas">
                       <div class="csv-processing-toolbar-atlas-item" style="margin-bottom: 7px" >
                           Click <span class="mx-2" ><MudIcon Icon="@Stepper.ViewFullCsvOperationsIcon"></MudIcon></span>to view&nbsp;<b>full csv</b>&nbsp;strategies
                       </div>
                       <div class="csv-processing-toolbar-atlas-item" >
                           Click <span class="mx-2" ><MudIcon Icon="@Stepper.ViewColumnOperationsIcon"></MudIcon></span>to view&nbsp;<b>column</b>&nbsp;strategies
                       </div>
                   </div>
                   @if (Stepper.UseSearchBar && columnNames != null)
                   {
                       <div class="csv-processing-toolbar-options">
                           <div class="csv-processing-toolbar-forward-back-container" >
                               @if (isPreviousEdit)
                               {
                                   var _class = !isNextEdit ? "forward-edit mr-7" : "forward-edit";
                                   <MudTooltip Text="Go back edit" RootClass="@_class" Delay="700" >
                                       <MudIconButton Size="Size.Small" Icon="@Icons.Material.Filled.ArrowBackIos" OnClick="x =>{ Stepper.Runner!.GoBackEdit(); ApplyCurrentColumnSort(); }" ></MudIconButton>
                                   </MudTooltip>
                               }
                               @if (isNextEdit)
                               {
                                   <MudTooltip Text="Go forward edit" Delay="700">
                                       <MudIconButton Class="back-edit" Size="Size.Small" Icon="@Icons.Material.Filled.ArrowForwardIos" OnClick="x => { Stepper.Runner!.GoForwardEdit(); ApplyCurrentColumnSort(); }" ></MudIconButton>
                                   </MudTooltip>
                               }
                           </div>
                           <div class="csv-processing-toolbar-full-csv-operations-button">
                               <MudTooltip Delay="750" Text="View Full Csv Strategies">
                                   <MudIconButton Disabled="Busy" Icon="@Stepper.ViewFullCsvOperationsIcon" OnClick="_ => TogglePopover(InternalColumnNames.FullCsvOperations)"></MudIconButton>
                               </MudTooltip>
                               @StrategyBucketPopover(InternalColumnNames.FullCsvOperations, Origin.BottomLeft, Origin.TopRight, true)
                           </div>
                           <MudTextField Disabled="Busy" T="string" Class="csv-processing-toolbar-search-field" DebounceInterval="Stepper.SearchDebounceInterval" Immediate="true" Label="Search Csv"
                                         HelperText="Value to search for" HelperTextOnFocus Variant="Variant.Outlined" Value="_sq" ValueChanged="x => SetSearchQuery(x)"
                                         Clearable OnClearButtonClick="x => SetSearchQuery(null)"/>
                           <CascadingValue TValue="CsvProcessingStepper" Value="@Stepper" IsFixed="true">
                               <MultiColumnSelect Disabled="Busy" InitializeWithStrategyBucketColumnName="false" Label="Columns To Search" @bind-ColumnNames="SearchColumns" SelectAll="true" SelectAllText="Search All Columns"></MultiColumnSelect>
                               <MultiTagSelect Disabled="Busy" Label="Tag Filter" @bind-Tags="_searchTags" HideNoTags="true"></MultiTagSelect>
                           </CascadingValue>
                       </div>
                   }
                   else
                   {
                       <div class="csv-processing-toolbar-full-csv-operations-button">
                           <div class="csv-processing-toolbar-forward-back-container" >
                               @if (Utils.IsValidIndex(Stepper.Runner?.CurrentRowEditIndex, Stepper.Runner?.CurrentReversibleEdits?.Count ?? -1))
                               {
                                   <MudIconButton Class="forward-edit" Size="Size.Small" Icon="@Icons.Material.Filled.ArrowBackIos" OnClick="x => Stepper.Runner.GoBackEdit()" ></MudIconButton>
                               }
                               @if (Utils.IsValidIndex(Stepper.Runner?.CurrentRowEditIndex + 1, Stepper.Runner?.CurrentReversibleEdits?.Count ?? -1))
                               {
                                   <MudIconButton Class="back-edit" Size="Size.Small" Icon="@Icons.Material.Filled.ArrowForwardIos" OnClick="x => Stepper.Runner.GoForwardEdit()" ></MudIconButton>
                               }
                           </div>
                           <MudTooltip Delay="750" Text="View Full Csv Strategies">
                               <MudIconButton Disabled="Busy" Icon="@Stepper.ViewFullCsvOperationsIcon" OnClick="_ => TogglePopover(InternalColumnNames.FullCsvOperations)"></MudIconButton>
                           </MudTooltip>
                           @StrategyBucketPopover(InternalColumnNames.FullCsvOperations, Origin.BottomLeft, Origin.TopRight, true)
                       </div>
                   }
               </div>;
    }

    private RenderFragment<CsvRow>? RowEditTemplate(int tagsColumnIndex, int referenceColumnIndex)
    {
        if (!Stepper.EnableRowEditing)
        {
            return null;
        }

        return row =>
        {
            return @<text>
                        @if (Stepper.EnableRowDeleting)
                        {
                            <MudTd></MudTd>
                        }
                        @if (Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning)
                        {
                            @TagDataCell(tagsColumnIndex, row, allowDelete: false)
                            @ReferencesDataCell(referenceColumnIndex, row)
                        }
                        @for (int i = 0; i < row.Count; i++)
                        {
                            if (i != tagsColumnIndex && i != referenceColumnIndex)
                            {
                                @EditCell(row, i)
                            }
                        }
                        @if (Stepper.TagsAndReferencesLocation == ColumnLocation.End)
                        {
                            @ReferencesDataCell(referenceColumnIndex, row)
                            @TagDataCell(tagsColumnIndex, row, allowDelete: false)
                        }
                    </text>;
        };
    }

    private RenderFragment StrategyBucketPopover(string column, Origin anchorOrigin, Origin transformOrigin, bool fullCsv)
    {
        _columnPopOverDict.TryAdd(column, false);
        if (!_columnStrategyBuckets.ContainsKey(column))
        {
            _columnStrategyBuckets.Add(column, new StrategyBucket(column, InvokeStateHasChanged));
        }
        _columnStrategyBuckets[column].SetOrigins(anchorOrigin, transformOrigin);
        return @<MudPopover Open="_columnPopOverDict[column]" Style="@($"max-height:{Stepper.MaxStrategySelectHeight}")" Class="csv-processing-popover"
                            OverflowBehavior="OverflowBehavior.FlipAlways" AnchorOrigin="anchorOrigin" TransformOrigin="transformOrigin">
                   <CascadingValue TValue="CsvProcessingStepper" Value="Stepper" IsFixed="true">
                       <CascadingValue TValue="StrategyBucket" Value="_columnStrategyBuckets[column]" IsFixed="true">
                           <MudList Clickable="true" Style="z-index: inherit">
                               <MudListSubheader>
                                   <div style="display: flex; flex-direction: row; justify-content: space-between">
                                       <MudText Class="mt-4" Typo="Typo.h5">
                                           @if (fullCsv)
                                           {
                                               @:Full Csv Strategies
                                           }
                                           else
                                           {
                                               @:Column Strategies&nbsp;
                                               @if (Stepper.ShowColumnNameInStrategySelect)
                                               {
                                                   @:(@column)
                                               }
                                           }
                                       </MudText>
                                       <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="x => TogglePopover(column, false)"></MudIconButton>
                                   </div>
                               </MudListSubheader>
                               @if (Stepper.SearchBar)
                               {
                                   <MudListItem>
                                       <div style="display: flex; flex-direction: row; gap: 60px; align-items: baseline;" >
                                           <MudTextField T="string" Disabled="_columnStrategyBuckets[column].IsAnySelected()" Immediate="true" Label="Search strategies" Variant="Variant.Outlined" Value="_columnStrategyBuckets[column].SearchQuery"
                                                         ValueChanged="_columnStrategyBuckets[column].SetSearchQuery"
                                                         Clearable="true" OnClearButtonClick="() => _columnStrategyBuckets[column].SetSearchQuery(string.Empty)" />
                                           @if (!fullCsv && Stepper.EnableRowEditing && Stepper.EnableChangeEditColumnValueType)
                                           {
                                               _columnValueTypes.TryAdd(column, Stepper.DefaultColumnValueType);
                                               <ColumnValueTypeSelect Style="max-width: 210px;" Label="Editing Type" ColumnValueType="@_columnValueTypes[column]" ColumnValueTypeChanged="x => SetColumnValueType(column, x)" ></ColumnValueTypeSelect>
                                           }
                                       </div>
                                   </MudListItem>
                               }
                               @if (fullCsv)
                               {
                                   if (FullCsvOptions != null)
                                   {
                                       @FullCsvOptions
                                   }
                               }
                               else if (ColumnOptions != null)
                               {
                                   @ColumnOptions(column)
                               }
                               @if (_columnStrategyBuckets[column].IsAnySelected() || Stepper.RunOperationNoneSelectedVisibility == RunOperationNoneSelectedVisibility.Disabled)
                               {
                                   <MudListItem>
                                       <div style="display: flex; flex-direction: row; align-items: center; justify-content: space-between;">
                                           <div></div>
                                           <MudButton Disabled="!_columnStrategyBuckets[column].StrategySelectedAndRunAllowed()" Variant="Variant.Filled" Color="Color.Info" OnClick="async x => {await _columnStrategyBuckets[column].StrategyPicked(); TogglePopover(column, false); }">Run Operation</MudButton>
                                       </div>
                                   </MudListItem>
                               }
                           </MudList>
                           @if (_columnPopOverDict[column] && Stepper.CloseBehaviour is CloseBehaviour.ClickAway or CloseBehaviour.CloseButtonAndClickAway)
                           {
                               <div @onclick="() => TogglePopover(column, false)" class="easy-csv-fullscreen-backdrop"></div>
                           }
                       </CascadingValue>
                   </CascadingValue>
               </MudPopover>;
    }

    private RenderFragment? ReferencesDataCell(int referenceColumnIndex, CsvRow row)
    {
        if (referenceColumnIndex >= 0)
        {
            var anchorOrigin = Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning ? Origin.BottomRight : Origin.BottomLeft;
            var transformOrigin = Stepper.TagsAndReferencesLocation == ColumnLocation.Beginning ? Origin.TopLeft : Origin.TopRight;
            var references = row.ProcessingReferences(referenceColumnIndex);
            return @<MudTd Class="extra-dense">
                       @if (references?.Any() == true && Stepper.Runner?.ReferenceCsvs.Count > 0)
                       {
                           int i = -1;
                           <MudChipSet>
                               @foreach (IGrouping<int, (int CsvIndex, int RowIndex)> group in references.Where(x => Utils.IsValidIndex(x.CsvIndex, Stepper.Runner?.ReferenceCsvs.Count ?? -1)).GroupBy(x => x.CsvIndex))
                               {
                                   i++;
                                   int groupIndex = i;
                                   var referenceGroup = new ReferenceGroup(row, groupIndex);
                                   _referencesOpen.TryAdd(referenceGroup, false);
                                   _referencesBackDropsOpen.TryAdd(referenceGroup, false); 
                                   string text = FormatReferenceText != null
                                       ? FormatReferenceText(group)
                                       : DefaultFormatReferenceText(group);
                                   <MudChip Text="@text" Color="@Stepper.ReferenceChipColor" Size="Size.Small" OnClick="x => _referencesOpen[referenceGroup] = true"/>
                                   <MudPopover AnchorOrigin="anchorOrigin" TransformOrigin="transformOrigin" Style="color: var(--mud-palette-dark-text); background-color: var(--mud-palette-grey-darker); padding: 10px; max-width: 1000px;" Open="_referencesOpen[referenceGroup]">
                                       <ChildContent>
                                           @{
                                               string referencesStr = references.Length == 1 ? "reference" : "references";
                                               var dictionaryArray = new Dictionary<string, string?>[references.Length];
                                               int j = 0;
                                               foreach (var reference in references)
                                               {
                                                   dictionaryArray[j] = Stepper.Runner.ReferenceCsvs[reference.CsvIndex].Csv.CsvContent[reference.RowIndex].ToStringDictionary();
                                                   j++;
                                               }
                                           }
                                           @ExampleCsv(dictionaryArray, $"{references.Length} {referencesStr} in {Stepper.Runner.ReferenceCsvs[group.Key].FileName}", false)
                                       </ChildContent>
                                   </MudPopover>

                               }
                           </MudChipSet>
                       }
                   </MudTd>;
        }
        return null;
    }
}
